use std::collections::HashSet;

use musik::{music::Primitive, Interval, Music};

type M = Music;

/// Exercise 6.1
/// Show that `retro ◦ retro`, `invert ◦ invert`,
/// and `retroInvert ◦ invertRetro` are the identity on values created by `line`.
/// (You may use the lemma that `reverse (reverse l) = l`.)
#[cfg(test)]
mod retro_invert {
    use musik::{Dur, Octave};

    use super::*;

    #[test]
    fn retro_is_involution() {
        let m = {
            let oc4 = Octave::ONE_LINED;
            let oc5 = Octave::TWO_LINED;
            Music::line(vec![
                M::C(oc5, Dur::EN),
                M::E(oc5, Dur::SN),
                M::G(oc5, Dur::EN),
                M::B(oc5, Dur::SN),
                M::A(oc5, Dur::EN),
                M::F(oc5, Dur::SN),
                M::D(oc5, Dur::EN),
                M::B(oc4, Dur::SN),
                M::C(oc5, Dur::EN),
            ])
        };

        assert_eq!(m.clone().retrograde().retrograde(), m);
    }

    #[test]
    fn invert_is_involution() {
        let m = {
            let oc5 = Octave::TWO_LINED;
            Music::line(vec![
                M::Fs(oc5, Dur::EN),
                M::A(oc5, Dur::EN),
                M::B(oc5, Dur::HN),
                M::B(oc5, Dur::QN),
                M::A(oc5, Dur::EN),
                M::Fs(oc5, Dur::EN),
                M::E(oc5, Dur::QN),
                M::D(oc5, Dur::EN),
                M::Fs(oc5, Dur::EN),
                M::E(oc5, Dur::HN),
                M::D(oc5, Dur::HN),
                M::Fs(oc5, Dur::QN),
            ])
        };

        assert_eq!(m.clone().invert().invert(), m);
    }

    #[test]
    fn invert_retro_is_inverse_to_retro_invert() {
        let m = {
            let oc5 = Octave::TWO_LINED;
            let oc6 = Octave::THREE_LINED;
            Music::line(vec![
                M::G(oc5, Dur::EN),
                M::As(oc5, Dur::EN),
                M::Cs(oc6, Dur::HN),
                M::Cs(oc6, Dur::EN),
                M::D(oc6, Dur::EN),
                M::Cs(oc6, Dur::EN),
            ])
        };

        assert_eq!(m.clone().invert_retro().retro_invert(), m);
    }
}

/// Exercise 6.2
/// Define a function `properRow :: Music Pitch -> Bool`
/// that determines whether or not its argument is a “proper” twelve-tone row,
/// meaning that: (a) it must have exactly twelve notes,
/// and (b) each unique pitch class is used exactly once (regardless of the octave).
/// Enharmonically equivalent pitch classes are not considered unique.
/// You may assume that the `Music Pitch` value is generated by the function `line`
/// but note that rests are allowed.
fn is_proper_row(m: Music) -> bool {
    let tones: Vec<_> = Vec::from(m)
        .into_iter()
        .map(|m| match m {
            Music::Prim(Primitive::Note(_, p)) => {
                let interval_with_c = (12 + Interval::from(p.class()).get_inner()) % 12;
                Some(Some(interval_with_c))
            }
            Music::Prim(Primitive::Rest(_)) => Some(None),
            _ => None,
        })
        .collect();

    if tones.contains(&None) {
        // an item is not a `Primitive`
        return false;
    }

    // ignore the rests
    let tones: Vec<_> = tones.into_iter().flatten().collect();
    if tones.len() != 12 {
        // proper row has size 12
        return false;
    }

    let uniq: HashSet<_> = tones.iter().collect();
    // proper row has all uniques PitchClass
    uniq.len() == tones.len()
}

/// Exercise 6.3
/// Define a function `palin :: Music Pitch -> Bool`
/// that determines whether or not a given line
/// (as generated by the `line` function) is a palindrome or not.
/// You should ignore rests, and disregard note durations —
/// the main question is whether or not the melody is a palindrome.
fn is_palindrome(m: Music) -> bool {
    let abs_pitches: Vec<_> = Vec::from(m)
        .into_iter()
        .map(|m| match m {
            Music::Prim(Primitive::Note(_, p)) => Some(Some(p.abs())),
            Music::Prim(Primitive::Rest(_)) => Some(None),
            _ => None,
        })
        .collect();

    if abs_pitches.contains(&None) {
        // an item is not a `Primitive`
        return false;
    }

    // ignore the rests
    let abs_pitches: Vec<_> = abs_pitches.into_iter().flatten().collect();
    abs_pitches.iter().copied().rev().collect::<Vec<_>>() == abs_pitches
}

/// Exercise 6.4
/// Define a function `retroPitches :: Music Pitch -> Music Pitch`
/// that reverses the pitches in a line, but maintains
/// the durations in the same order from beginning to end.
fn retro_pitches(m: Music) -> Option<Music> {
    let abs_pitches = Vec::from(m)
        .into_iter()
        .map(|m| {
            if let Music::Prim(p) = m {
                Some(p)
            } else {
                None
            }
        })
        .collect::<Option<Vec<_>>>()?;

    let (durations, pitches): (Vec<_>, Vec<_>) = abs_pitches
        .into_iter()
        .map(|p| match p {
            Primitive::Note(d, p) => (d, Some(p)),
            Primitive::Rest(d) => (d, None),
        })
        .unzip();

    #[allow(clippy::option_if_let_else)]
    let musics = pitches.into_iter().rev().zip(durations).map(|(p, d)| {
        if let Some(p) = p {
            Music::note(d, p)
        } else {
            Music::rest(d)
        }
    });

    Some(Music::line(musics.collect()))
}

#[cfg(test)]
mod tests {
    use musik::{Dur, Octave};

    use super::*;

    #[test]
    fn test_retro_pitches() {
        let oc4 = Octave::ONE_LINED;
        let m = Music::line(vec![
            M::C(oc4, Dur::EN),
            M::rest(Dur::SN),
            M::D(oc4, Dur::QN),
        ]);

        assert_eq!(
            retro_pitches(m).unwrap(),
            Music::line(vec![
                M::D(oc4, Dur::EN),
                M::rest(Dur::SN),
                M::C(oc4, Dur::QN),
            ])
        );
    }

    #[test]
    fn strip_zeros() {
        let oc4 = Octave::ONE_LINED;
        let m = M::C(oc4, Dur::EN) + M::D(oc4, Dur::EN).times(16);
        assert_eq!(
            m.drop(Dur::HN).take(Dur::HN).remove_zeros(),
            M::D(oc4, Dur::EN).times(4).remove_zeros()
        );
    }
}
