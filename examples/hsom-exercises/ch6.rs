use std::collections::HashSet;

use num_rational::Ratio;

use musik::{
    instruments::{PercussionSound, StandartMidiInstrument},
    music::{Primitive, Volume},
    rests, Dur, Interval, Music, Octave, Pitch, TrillOptions,
};

type M = Music;

/// Exercise 6.1
/// Show that `retro ◦ retro`, `invert ◦ invert`,
/// and `retroInvert ◦ invertRetro` are the identity on values created by `line`.
/// (You may use the lemma that `reverse (reverse l) = l`.)
#[cfg(test)]
mod retro_invert {
    use musik::{Dur, Octave};

    use super::*;

    #[test]
    fn retro_is_involution() {
        let m = {
            let oc4 = Octave::ONE_LINED;
            let oc5 = Octave::TWO_LINED;
            Music::line(vec![
                M::C(oc5, Dur::EN),
                M::E(oc5, Dur::SN),
                M::G(oc5, Dur::EN),
                M::B(oc5, Dur::SN),
                M::A(oc5, Dur::EN),
                M::F(oc5, Dur::SN),
                M::D(oc5, Dur::EN),
                M::B(oc4, Dur::SN),
                M::C(oc5, Dur::EN),
            ])
        };

        assert_eq!(m.clone().retrograde().retrograde(), m);
    }

    #[test]
    fn invert_is_involution() {
        let m = {
            let oc5 = Octave::TWO_LINED;
            Music::line(vec![
                M::Fs(oc5, Dur::EN),
                M::A(oc5, Dur::EN),
                M::B(oc5, Dur::HN),
                M::B(oc5, Dur::QN),
                M::A(oc5, Dur::EN),
                M::Fs(oc5, Dur::EN),
                M::E(oc5, Dur::QN),
                M::D(oc5, Dur::EN),
                M::Fs(oc5, Dur::EN),
                M::E(oc5, Dur::HN),
                M::D(oc5, Dur::HN),
                M::Fs(oc5, Dur::QN),
            ])
        };

        assert_eq!(m.clone().invert().invert(), m);
    }

    #[test]
    fn invert_retro_is_inverse_to_retro_invert() {
        let m = {
            let oc5 = Octave::TWO_LINED;
            let oc6 = Octave::THREE_LINED;
            Music::line(vec![
                M::G(oc5, Dur::EN),
                M::As(oc5, Dur::EN),
                M::Cs(oc6, Dur::HN),
                M::Cs(oc6, Dur::EN),
                M::D(oc6, Dur::EN),
                M::Cs(oc6, Dur::EN),
            ])
        };

        assert_eq!(m.clone().invert_retro().retro_invert(), m);
    }
}

/// Exercise 6.2
/// Define a function `properRow :: Music Pitch -> Bool`
/// that determines whether or not its argument is a “proper” twelve-tone row,
/// meaning that: (a) it must have exactly twelve notes,
/// and (b) each unique pitch class is used exactly once (regardless of the octave).
/// Enharmonically equivalent pitch classes are not considered unique.
/// You may assume that the `Music Pitch` value is generated by the function `line`
/// but note that rests are allowed.
fn is_proper_row(m: Music) -> bool {
    let tones: Vec<_> = Vec::from(m)
        .into_iter()
        .map(|m| match m {
            Music::Prim(Primitive::Note(_, p)) => {
                let interval_with_c = (12 + Interval::from(p.class()).get_inner()) % 12;
                Some(Some(interval_with_c))
            }
            Music::Prim(Primitive::Rest(_)) => Some(None),
            _ => None,
        })
        .collect();

    if tones.contains(&None) {
        // an item is not a `Primitive`
        return false;
    }

    // ignore the rests
    let tones: Vec<_> = tones.into_iter().flatten().collect();
    if tones.len() != 12 {
        // proper row has size 12
        return false;
    }

    let uniq: HashSet<_> = tones.iter().collect();
    // proper row has all uniques PitchClass
    uniq.len() == tones.len()
}

/// Exercise 6.3
/// Define a function `palin :: Music Pitch -> Bool`
/// that determines whether or not a given line
/// (as generated by the `line` function) is a palindrome or not.
/// You should ignore rests, and disregard note durations —
/// the main question is whether or not the melody is a palindrome.
fn is_palindrome(m: Music) -> bool {
    let abs_pitches: Vec<_> = Vec::from(m)
        .into_iter()
        .map(|m| match m {
            Music::Prim(Primitive::Note(_, p)) => Some(Some(p.abs())),
            Music::Prim(Primitive::Rest(_)) => Some(None),
            _ => None,
        })
        .collect();

    if abs_pitches.contains(&None) {
        // an item is not a `Primitive`
        return false;
    }

    // ignore the rests
    let abs_pitches: Vec<_> = abs_pitches.into_iter().flatten().collect();
    abs_pitches.iter().copied().rev().collect::<Vec<_>>() == abs_pitches
}

/// Exercise 6.4
/// Define a function `retroPitches :: Music Pitch -> Music Pitch`
/// that reverses the pitches in a line, but maintains
/// the durations in the same order from beginning to end.
fn retro_pitches(m: Music) -> Option<Music> {
    let abs_pitches = Vec::from(m)
        .into_iter()
        .map(|m| {
            if let Music::Prim(p) = m {
                Some(p)
            } else {
                None
            }
        })
        .collect::<Option<Vec<_>>>()?;

    let (durations, pitches): (Vec<_>, Vec<_>) = abs_pitches
        .into_iter()
        .map(|p| match p {
            Primitive::Note(d, p) => (d, Some(p)),
            Primitive::Rest(d) => (d, None),
        })
        .unzip();

    #[allow(clippy::option_if_let_else)]
    let musics = pitches.into_iter().rev().zip(durations).map(|(p, d)| {
        if let Some(p) = p {
            Music::note(d, p)
        } else {
            Music::rest(d)
        }
    });

    Some(Music::line(musics.collect()))
}

#[cfg(test)]
mod tests {
    use musik::{Dur, Octave};

    use super::*;

    #[test]
    fn test_retro_pitches() {
        let oc4 = Octave::ONE_LINED;
        let m = Music::line(vec![
            M::C(oc4, Dur::EN),
            M::rest(Dur::SN),
            M::D(oc4, Dur::QN),
        ]);

        assert_eq!(
            retro_pitches(m).unwrap(),
            Music::line(vec![
                M::D(oc4, Dur::EN),
                M::rest(Dur::SN),
                M::C(oc4, Dur::QN),
            ])
        );
    }

    #[test]
    fn strip_zeros() {
        let oc4 = Octave::ONE_LINED;
        let m = M::C(oc4, Dur::EN) + M::D(oc4, Dur::EN).times(16);
        assert_eq!(
            m.drop(Dur::HN).take(Dur::HN).remove_zeros(),
            M::D(oc4, Dur::EN).times(4).remove_zeros()
        );
    }
}

// TODO: play me
fn stars_and_stripes() -> Music {
    type M = Music;

    let oc5 = Octave::TWO_LINED;
    let oc6 = Octave::THREE_LINED;
    let oc7 = Octave::FOUR_LINED;

    let melody = Music::line(vec![
        // bar 1
        M::Bf(oc6, Dur::EN)
            .trill(Interval::tone(), TrillOptions::Count(5))
            .unwrap(),
        M::Ef(oc7, Dur::EN),
        M::Ef(oc6, Dur::EN),
        M::Ef(oc7, Dur::EN),
        // bar 2
        M::Bf(oc6, Dur::SN),
        M::C(oc7, Dur::SN),
        M::Bf(oc6, Dur::SN),
        M::G(oc6, Dur::SN),
        M::Ef(oc6, Dur::EN),
        M::Bf(oc5, Dur::EN),
        // bar 3
        M::Ef(oc6, Dur::SN),
        M::F(oc6, Dur::SN),
        M::G(oc6, Dur::SN),
        M::Af(oc6, Dur::SN),
        M::Bf(oc6, Dur::EN),
        M::Ef(oc7, Dur::EN),
        // bar 4
        M::Bf(oc6, Dur::QN)
            .trill(Interval::tone(), Dur::TN)
            .unwrap(),
        M::Bf(oc6, Dur::SN),
        M::rest(Dur::DEN),
    ]);

    melody.with_instrument(StandartMidiInstrument::Flute)
}

/// Exercise 6.6
///
/// Related to trills and grace notes in Western classical music
/// are the notions of `mordent`, `turn`, and `appoggiatura`.
///
/// <https://en.wikipedia.org/wiki/Ornament_(music)>
mod ornamentations {
    use super::*;

    fn mordent(music: Music, upper: bool) -> Result<Music, String> {
        if let Music::Prim(Primitive::Note(d, p)) = music {
            let other = if upper {
                Interval::tone()
            } else {
                -Interval::tone()
            };
            Ok(Music::line(vec![
                Music::note(d / 8, p),
                Music::note(d / 8, p.trans(other)),
                Music::note(d / 4, p),
                Music::note(d / 2, p),
            ]))
        } else {
            Err("Can only construct a mordent from a note".into())
        }
    }

    fn turn(music: Music, upper: bool) -> Result<Music, String> {
        if let Music::Prim(Primitive::Note(d, p)) = music {
            let other = if upper {
                Interval::tone()
            } else {
                -Interval::tone()
            };
            Ok(Music::line(vec![
                Music::note(d / 4, p.trans(other)),
                Music::note(d / 4, p),
                Music::note(d / 4, p.trans(-other)),
                Music::note(d / 4, p),
            ]))
        } else {
            Err("Can only construct a turn from a note".into())
        }
    }
}

// TODO: play me
fn funk_groove() -> Music {
    let p1 = PercussionSound::LowTom.note(Dur::QN);
    let p2 = PercussionSound::AcousticSnare.note(Dur::EN);
    let m1 = Music::line(vec![
        p1.clone(),
        rests::QN,
        p2.clone(),
        rests::QN,
        p2.clone(),
        p1.clone(),
        p1,
        rests::QN,
        p2,
        rests::EN,
    ]);
    let m2 = PercussionSound::ClosedHiHat
        .note(Dur::BN)
        .roll(Dur::EN)
        .unwrap();

    (m1 | m2)
        .times(4)
        .take(Dur::from(8))
        .with_instrument(StandartMidiInstrument::Percussion)
        .with_tempo(3)
}

/// Exercise 6.7
/// Write a program that generates all of the General MIDI
/// percussion sounds, playing through each of them one at a time.
fn sequence_all_percussions() -> Music {
    let dur = Dur::QN;
    Music::line(
        enum_iterator::all::<PercussionSound>()
            .map(|s| s.note(dur))
            .collect(),
    )
}

// TODO: Exercise 6.8
//  https://www.songsterr.com/a/wsa/nirvana-in-bloom-drum-tab-s295

// TODO: play me
fn test_volume(vol: Volume) -> Music<(Pitch, Volume)> {
    type M = Music;

    let oc4 = Octave::ONE_LINED;
    Music::line(vec![
        M::C(oc4, Dur::QN),
        M::D(oc4, Dur::QN),
        M::E(oc4, Dur::QN),
        M::C(oc4, Dur::QN),
    ])
    .with_volume(vol)
}

/// Exercise 6.9
/// Using mMap, define a function that
/// scales the volume of each note in `m` by the factor `s`.
fn scale_volume(m: Music<(Pitch, Volume)>, s: Ratio<u8>) -> Music<(Pitch, Volume)> {
    m.map(|(p, v)| {
        let new = (Ratio::from_integer(v.0) * s).to_integer();
        (p, Volume(new))
    })
}
